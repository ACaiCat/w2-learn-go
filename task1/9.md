# Bonus 4

## 这个代码实现了什么功能？
输出6个质数

## 这个代码利用了golang的什么特性？
goroutine和channel

## 这个代码相较于普通写法，是否有性能上的提升？（性能提升：求解速度更快了）
### 逻辑
先运行了一个执行generate的routine来生成数据，并传给第一个filter作为in管道，
每个filter都按照顺序存有一个质数，且in管道和out管道呈链状连接，
保证在最后一个goroutine中传出的数不会被比它小的任何质数整除，即为所需的质数。

```text
  generate -> filter1 (prime: 2) -> filter2 (prime: 3) -> ... -> main (不会被比它小的任何质数整除)
 生成自增序列      过滤2的倍数            过滤3的倍数        末端输出质数，然后拼接新的filter开始下一轮计算
```

### 性能
filter链上的所有goroutine都并行进行运算，且受到in和out管道的阻塞调控（只有在需要时链上的goroutine才会开始计算，避免过度运算的开销），
相比传统的递归求解可以更好的利用多核性能